# 死锁

1. 死锁产生的条件
 * 互斥条件：一个资源每次只能被一个进程使用
 * 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
 * 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
 * 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系
2. 死锁停留位置
  ![](https://raw.githubusercontent.com/ES201614353201/ES2016_14353201/master/%E6%AD%BB%E9%94%81.PNG)  
  
3. 产生死锁原因
程序先调用a.methodB,这时a的所拥有的资源会被加锁，然后调度到线程t，调用b.methodA。开始的时候CPU分配的时间片足够线程t完成，而随着线程t的优先级队列不断改变，所获取的时间片减少。当运行a.methodB的时候，时间片用完了，但是这个函数还没有运行完毕，这时会中断,运行线程t,调用b.methodA,然而此时要调用到a的资源，而a的资源被加锁了，这时b就只能等待a的资源释放，然而当a.methodB再次重新运行时，要调用b的资源时，b的资源也被加锁了。这时就双方陷入无限的循环，没有一方能够释放出资源给另一方使用，这时死锁就产生了。


